# Schema version of this manifest
# Lets you evolve format later without breaking old repos
# If version 1 uses healthcheck.path, but version 2 uses healthcheck.url, when we see version 1, we know what needs to happen with healthcheck
version: 1

# Logical service name Lighthouse uses internally
service: cove

image:
  # image name
  name: cove
  build:
    # the directory that Docker will use as its build context (everything under this folder gets sent to the Docker Daemon)
    # . = repo root
    context: .
    # Path to the dockerfile relative to the context (repo root)
    dockerfile: Dockerfile
    #Buildtime arguments (not secrets). Passed into ARG instructions in the Dockerfile
    # GOFLAGS=-trimpath - This is a go optimization flag that strips local paths from binaries
      # This avoids leaking your local build paths
    args:
      - GOFLAGS=-trimpath

run:
  # Overrides CMD in the image. Empty = use the Dockerfile default
  # Lets you override the default startup commnad if you ever need to without editing the Dockerfile
  command: []
  # Some repos will expose multiple ports (web + metrics, web + admin). Naming them avoids guessing and lets Lighthouse's host config bind them safely
  ports:
      # logical name for this port so the host can map it
    - name: http
      # port inside the container that the app listens to
      container_port: 8080
      # tcp/udp - default is tcp
      protocol: tcp
      # true - this port should be reachable from outside
      # false - Internal only - exposed APIs for other things on the server
      public: true
    - name: metrics
      container_port: 9090
      protoco: tcp
      public: false
  # Each service may need state (like a DB or cache). This describes what the container expects without hardcoding your host path
  # We might need to store data on shutdown/shutoff. Data to be accessed through shutdowns, restarts, rebuilds, deployments. 
  volumes:
      # Logical name for this volume
    - name: data
      #  Where it shows up inside the container
      mount_path: /app/data
      # Persistent, bind, tmpfs
        # Persistent - Docket-managed volume (safe by default)
        # bind - Mount a host folder
        # tmpfs - in memory ephemeral storage
      type: persistant
      # a hint for resource planning (not enforced by Docker itself but Lighthouse can enforce quotas if I add it later)
      size: 1Gi
  # Static environment variables, safe to check in (non-sensative)
  env:
    - LOG_LEVEL=INFO
  # Names of secrets this service should fetch from Cove (key vault)
    # Keeps sensative data outside of git
    # Lighthouse can resolve these from cove at runtime and inject them into the container
  env_from_cove:
    - BOTSUITE_TOKEN
    - DATABASE_URL
  #This is unecessary, but will help if I have stages. Lighthouse can only promote contaienrs that pass health checks
  healthcheck:
    # HTTP path lighthouse should check inside the container
    path: /healthz
    # how often it should check
    interval: 10s
    # how long to wait before declaring failure
    timeout: 3s
    # number of failures before marking contaier unhealthy
    retries: 6
  #Resource requests/limits for the container
  # cores, and memory alloted to a container
  resources:
    cpu: "0.5"
    memory: "512Mi"

# handles how this container should handle lifecycle
deploy:
  # method for rolling out updates
    # blue_green - spin up a new container, check health, swap traffic then remove old
    # recreate - stop old, start new (downtime)
    # canary - future feature (grudual rollout)
  strategy: blue_green
  # Docker restart policy (always, unless-stopped, no, on-failure)
  restart: unless-stopped
  # Metadata tagsfor this container/image (easy to filter/cleanup)
  labels:
    manged-by: lighthouse
  # Docker networks this container should join
  networks:
    - app-net
